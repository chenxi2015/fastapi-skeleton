import sys
import os
import subprocess
import argparse
from typing import List
from sqlalchemy import create_engine, inspect

# Add the project root directory to sys.path
sys.path.append(os.getcwd())

try:
    from app.core.config import settings
except ImportError:
    print(
        "Error: Could not import settings. Make sure you are running this script from the project root."
    )
    sys.exit(1)


def get_db_url():
    """Get synchronous DB URL from settings"""
    db_url = str(settings.SQLALCHEMY_DATABASE_URI)
    if "aiomysql" in db_url:
        # sqlacodegen requires a synchronous driver
        db_url = db_url.replace("aiomysql", "pymysql")
    return db_url


def get_all_tables(db_url: str) -> List[str]:
    """Get list of all tables in the database"""
    engine = create_engine(db_url)
    inspector = inspect(engine)
    return inspector.get_table_names()


def generate_model_for_table(table_name: str, output_dir: str, db_url: str):
    """Generate model file for a single table"""
    output_file = os.path.join(output_dir, f"{table_name}.py")

    # Construct command
    # Using 'sqlacodegen' directly assuming it's in PATH or venv bin
    cmd = ["sqlacodegen", "--tables", table_name, "--noviews", db_url]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        code = result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error generating model for table '{table_name}': {e.stderr}")
        return

    if not code:
        print(f"Warning: No code generated for table '{table_name}'. Output was empty.")
        return

    # Process code to match project style
    lines = code.splitlines()
    final_lines = []

    # Logic to remove generic Base class definition generated by sqlacodegen
    skip_mode = False

    for line in lines:
        s_line = line.strip()

        # Skip coding headers
        if s_line.startswith("# coding:"):
            continue

        # Detect start of generated Base class definition to skip
        if not skip_mode:
            # sqlacodegen typically generates `class Base(DeclarativeBase):` or similar
            if s_line.startswith("class Base(") and "DeclarativeBase" in s_line:
                skip_mode = True
                continue
            if s_line.startswith("metadata = Base.metadata"):
                continue

        if skip_mode:
            # If inside the skipped block, check if it ends
            if not s_line:
                # Empty line might be inside class or end of it
                continue
            if s_line == "pass":
                continue
            # If line is indented, it belongs to the class -> skip
            if line.startswith("    ") or line.startswith("\t"):
                continue

            # Found unindented line -> block ended
            skip_mode = False

        # Add the line if not skipping
        if not skip_mode:
            final_lines.append(line)

    # Reorganize imports and inject our Base
    output_lines = []
    imports = []
    rest = []

    for line in final_lines:
        if line.startswith("import ") or line.startswith("from "):
            # Remove SQLAlchemy declarative_base if unused (we use our own Base)
            if "declarative_base" in line and "sqlalchemy.orm" in line:
                # We often still need Mapped/mapped_column from this line, so be careful.
                # sqlacodegen usually outputs: `from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column`
                # We want to keep Mapped/mapped_column but remove DeclarativeBase if possible, or just ignore.
                pass
            imports.append(line)
        else:
            rest.append(line)

    # Add our project's Base import
    our_base_import = "from app.db.base import Base"
    if our_base_import not in imports:
        imports.append(our_base_import)

    output_lines.extend(imports)
    output_lines.append("")
    output_lines.extend(rest)

    content = "\n".join(output_lines)

    # Cleanup multiple newlines
    while "\n\n\n" in content:
        content = content.replace("\n\n\n", "\n\n")

    # Ensure directory exists
    os.makedirs(output_dir, exist_ok=True)

    with open(output_file, "w") as f:
        f.write(content)

    print(f"Generated: {output_file}")

    # Format with black if available
    try:
        subprocess.run(
            ["uv", "run", "black", output_file], capture_output=True, check=False
        )
    except subprocess.SubprocessError:
        pass


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate SQLAlchemy models from database tables."
    )

    parser.add_argument(
        "table",
        nargs="?",
        default="all",
        help="Specific table name to generate model for. Defaults to 'all' to generate for all tables.",
    )

    parser.add_argument(
        "--output",
        "-o",
        default="app/models",
        help="Output directory where model files will be saved. Defaults to 'app/models'.",
    )

    args = parser.parse_args()

    try:
        db_url = get_db_url()
        print("Connecting to database...")

        if args.table == "all":
            tables = get_all_tables(db_url)
            print(f"Found {len(tables)} tables: {', '.join(tables)}")

            count = 0
            for table_name in tables:
                # Skip alembic migration table
                if table_name == "alembic_version":
                    continue

                generate_model_for_table(table_name, args.output, db_url)
                count += 1
            print(f"Successfully generated {count} models.")

        else:
            # Generate for single table
            generate_model_for_table(args.table, args.output, db_url)

    except Exception as e:
        print(f"An error occurred: {e}")
        sys.exit(1)
